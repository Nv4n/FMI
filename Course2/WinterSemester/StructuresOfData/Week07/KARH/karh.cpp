#include <iostream>
#include <cstdlib>
#include <vector>
#include <ctime>
#include <algorithm>
#include <string>

unsigned counter = 0;

struct Option {
    Option(const std::string &, const double);

    double val = 0;
    std::string text;
};

Option::Option(const std::string &txt, const double val) : text(txt), val(val) {
}

class Question {
public:
    Question(const std::string &);

    void AddOption(const std::string &, const double);

    void AskQuestion();

    int AnswerQuestion();

private:
    std::string m_Question;
    std::vector<Option> m_Answers;
    double m_Score = 0;
};

void Question::AddOption(const std::string &rhs, const double val) {
    Option opt(rhs, val);
    m_Answers.push_back(opt);
}

Question::Question(const ::std::string &task) : m_Question(task) {
}

int Randomize(const int i) {
    return std::rand() % i;
}

void Question::AskQuestion() {
    std::cout << m_Question << "\n\n";
    std::srand(unsigned(std::time(0)));
    for (unsigned i = 0; i < m_Answers.size(); ++i)
        std::swap(m_Answers[Randomize(m_Answers.size())], m_Answers[Randomize(m_Answers.size())]);
    for (unsigned i = 0; i < m_Answers.size(); ++i) {
        char ind = i + 65;
        std::cout << ind << ' ' << m_Answers[i].text << '\n';
    }
}

int Question::AnswerQuestion() {
    char tmp = 'v';
    unsigned tmpToInt;
    std::cin >> tmp;
    tmpToInt = tmp;
    do {
        if (tmpToInt < 97)
            tmpToInt -= 65;
        else
            tmpToInt -= 97;
        m_Score += m_Answers[tmpToInt].val;
        std::cin >> tmp;
        tmpToInt = tmp;
    } while (tmp != 's' && tmp != 'S');
    std::cout << "Резултат: " << m_Score << "\nВерен отговор(и): ";
    for (unsigned i = 0; i < m_Answers.size(); ++i)
        if (m_Answers[i].val > 0)
            std::cout << char(i + 65) << ' ';
    std::cout << "\nВъведи някой символ...\n";
    if (m_Score > 0)
        counter++;
    return m_Score;
}

int main() {
    setlocale(LC_ALL, "Bulgarian");

    std::cout
            << "Тест 1 по КАРХ.\nИзготвен от Марто, Даката, Икбал и М.\nПреведен от shlokavica на български от Ицо.\n";
    std::cout << "За да отговорите на някой въпрос, въведете буквата (буквите) и когато сте готови въведете 's'.\n";
    std::cout
            << "Съобразете се как работи std::cin.\nАко желаете симулация без повторни опити, натиснете r.\nАко желаете въпросите, които объркате да се запазват, натиснете произволен бутон.\n";
    char useless;
    std::cin >> useless;
    bool flag = (useless == 'r' ? 1 : 0);
    system("CLS");
    std::vector<Question> exam;
    std::srand(unsigned(std::time(0)));

    //cache memory
    Question d0(
            "Кой от трите метода на разполагане на блокове от оперативната памет се имплементира най-лесно (изберете едно)?");
    d0.AddOption("Директно съпоставяне", 1);
    d0.AddOption("Пълна асоциативност", -1);
    d0.AddOption("Множествена асоциативност", -1);
    exam.push_back(d0);

    Question d1("Отбележете невярното твърдение (изберете едно):");
    d1.AddOption("Главната (DRAM) памет е по-бавна от SRAM паметта", -1);
    d1.AddOption("DRAM консумира повече енергия от SRAM", -1);//tuka rusalchoto go smeni,moje i da e greshno
    d1.AddOption("Кеш-паметта е малка, бърза и SRAM базирана", -1);
    d1.AddOption("SRAM е по-евтина DRAM", 1);
    exam.push_back(d1);

    Question d2("Каква е корелацията капацитет и бързодействие при компютърните памети (изберете едно)?");
    d2.AddOption("Пропорционална", -1);
    d2.AddOption("Обратнопропорционална", 1);//verniqt
    d2.AddOption("Няма корелация", -1);
    exam.push_back(d2);

    Question d3("Какъв е формата на линията при кеш-паметта с множествена асоциативност (изберете едно)?");
    d3.AddOption("таг, дума", -1);
    d3.AddOption("таг, линия, дума", -1);
    d3.AddOption("таг, множество, дума", 1);//verniqt
    exam.push_back(d3);

    Question d4("Кой вид памети са по-бързи от кеш-паметите (изберете едно)?");
    d4.AddOption("Регистрите", 1);//tova e verniqt otgovor
    d4.AddOption("Флаш паметите", -1);
    d4.AddOption("Главната памет", -1);
    exam.push_back(d4);

    Question d5(
            "Методът, при който обновяване на главната памет настъпва асинхронно след премахване на дума от кеша се нарича (изберете едно)?");
    d5.AddOption("Защитен запис", -1);
    d5.AddOption("Write-back", 1);//verniqt
    d5.AddOption("Cache-write", -1);
    d5.AddOption("Write-through", -1);
    exam.push_back(d5);

    Question q31(
            "Методът, при който обновяване на главната памет настъпва синхронно след премахване на дума от кеша се нарича (изберете едно)?");
    q31.AddOption("Защитен запис", -1);
    q31.AddOption("Write-back", -1);//verniqt
    q31.AddOption("Cache-write", -1);
    q31.AddOption("Write-trough", 1);
    exam.push_back(q31);

    Question d6("Какъв е форматът на линията при кеш-памет с пълна асоциативност?");
    d6.AddOption("таг, линия, дума", -1);
    d6.AddOption("таг, дума", 1);
    d6.AddOption("таг, множество, дума", -1);
    exam.push_back(d6);

    Question d7(
            "Дадена е машина с побайтово адресируема основна памет с размер 2^16 байта и размер на блока 8 байта. Кеш-паметта е с \nдиректна организация и се състои от 32 линии. Какъв е максималният брой байтове, които могат да бъдат разположени в кеш-паметта (изберете едно)?");
    d7.AddOption("256B", 1);//verniqt
    d7.AddOption("1024B", -1);
    d7.AddOption("512B", -1);
    d7.AddOption("128B", -1);
    d7.AddOption("64B", -1);
    exam.push_back(d7);

    Question d8("LFU е алгоритъм за:");
    d8.AddOption("заместване на най-често използваната страница от кеш-паметта", -1);
    d8.AddOption("заместване на най-неизползваната страница в кеш-паметта", 1);//veren
    d8.AddOption("заместване на някои от използваните страници в кеш-паметта", -1);
    d8.AddOption("периодично изчистване признаците за обръщение към най-рядко използваните страници в кеш-паметта", -1);
    exam.push_back(d8);

    Question d9(
            "Дадена е машина с побайтово адресируема основна памет и 2-кратен множествено асоциативен кеш. Кеш-логиката интерпретира адреса от паметта\nкакто следва: 14 бита за таг, 8 бита за множество, 2 бита за адресиране на дума\n.Колко е максималният брой на блоковете в главната памет (изберете едно)?");
    d9.AddOption("Не може да бъде определен", -1);
    d9.AddOption("2^2", -1);
    d9.AddOption("2^8", -1);
    d9.AddOption("2^22", 1);//veren
    d9.AddOption("2^14", -1);
    d9.AddOption("2^24", -1);
    exam.push_back(d9);

    Question d10(
            "Кеш-памет с асоциативна организация е с капацитет 64 линии, разделени на множества с по 16 линии всяко. Основната памет съдържа 4К блока с по 128 думи всяка.\nПосочете адресният формат, който й съответства (форматът е: tag, set, word):");
    d10.AddOption("8 2 7", 1);//towa bi trqbwalo da e vqrno , but who knows, definitely not Cvetanov
    d10.AddOption("14 8 4", -1);
    d10.AddOption("14 8 7", -1);
    d10.AddOption("4 8 7", -1);
    exam.push_back(d10);

    Question d11(
            "Методът, при който запис на данните се извършва само в кеш-паметта, а състоянието на кеш-блока се отбелязва\nкато обикновено в управляващото поле с признак, наречен \"update\" или \"dirty\" се нарича:");
    d11.AddOption("Обратен запис (Write back)", 1);
    d11.AddOption("Едновременен запис (Write through)", -1);
    exam.push_back(d11);

    Question q36("Какъв е форматът на линията при кеш-памет с асоциативна организация?");
    q36.AddOption("таг, линия, дума", -1);
    q36.AddOption("таг, дума", 1);
    q36.AddOption("таг, множество, дума", -1);
    exam.push_back(q36);

    Question q37(
            "При кой от трите метода на разполагане блокове от операционната памет в кеша е най-малко вероятно два блока да бъдат записани на една и съща линия?");
    q37.AddOption("Пълна асоциативност", 1);
    q37.AddOption("Директно съпоставяне", -1);
    q37.AddOption("Множествена асоциативност", -1);
    exam.push_back(q37);

    Question q0(
            "Дадена е машина с побайтово адресируема основна памет 2^24 байта и с кеш за данни с директна организация и с капацитет 64k и 32-байтови блокове. Колко бита са необходими за таг, блок и отместване?");
    q0.AddOption("8 бита за таг, 5 бита за блок, 11 бита за уникална дума", -1);
    q0.AddOption("8 бита за таг, 11 бита за блок, 5 бита за уникална дума", 1);
    q0.AddOption("11 бита за таг, 8 бита за блок, 5 бита за уникална дума", -1);
    exam.push_back(q0);

    Question q1("Кои от изброените подходи способстват за намаляване на латентността при зареждане на данни в кеша?");
    q1.AddOption("Отложен запис на данни", 0.34);
    q1.AddOption("Зареждане при поискване", 0.33);
    q1.AddOption("Обратен запис", -1);
    q1.AddOption("Едновременен запис", -1);
    q1.AddOption("Спекулативно зареждане", 0.33);
    exam.push_back(q1);

    Question q25("Кое от изброените не е вярно за кеш-паметта?");
    q25.AddOption(
            "Намира се в адресното пространство на процесора и може да се адресира с помощта на машинните инструкции",
            1);
    q25.AddOption("Осигурява бърз достъп до интензивно използваните данни чрез тяхното предварително зареждане", -1);
    q25.AddOption("Съгласува интерфейса на процесора и контролера на паметта", -1);
    exam.push_back(q25);

    Question q33(
            "Кои от изброените алгоритми за управление на заместването на блокове при кеш-паметите се основават на оценка на вероятността за обръщение към блока в бъдеще време?");
    q33.AddOption("Алгоритъм за случайния избор RC (random choice)", -1);
    q33.AddOption("Алгоритъм FIFO", -1);
    q33.AddOption("Алгоритъм LFU (Least Frequently Used)", -1);
    q33.AddOption("Алгоритъм LRU (Least Recently Used)", -1);
    q33.AddOption("Нито един от посочените.",
                  1);//Algoritmite za upravlenie na zamestvaneto, koito se osnovavat na ocenka na veroqtnostta za obryshtenie na bloka v budeshte vreme se narichat fizicheski nerealiziruemi
    exam.push_back(
            q33);                        //src http://www.tyanev.com/resources/books/ComputerOrganization/OK_632.HTM?fbclid=IwAR1HMqF44Y7Y8QsChrI4_m4pZPm4yy4BZJmsDMuHMyWh2jLShvHi7oc6mcw

    //virtual memory
    Question q11("Кой от посочените методи не е метод за преобразуване на виртуални адреси?");
    q11.AddOption("Метод на странична организация", -1);
    q11.AddOption("Метод на сегментно-странична организация", -1);
    q11.AddOption("Метод на локалността", 1);
    q11.AddOption("Метод на сегментна организация", -1);
    exam.push_back(q11);

    Question q3("Колко е максималният брой страници с размер на страниците 4k при 32-битов адрес?");
    q3.AddOption("1M", 1);
    q3.AddOption("64k", -1);
    q3.AddOption("5k", -1);
    q3.AddOption("20k", -1);
    exam.push_back(q3);

    Question q4("Какво съдържа TLB при странична организация на паметта?");
    q4.AddOption("Моментна карта на състоянието на страниците на оперативната памет", 1);
    q4.AddOption("Таблица с номера на физически страници, принадлежащи на даден процес", -1);
    q4.AddOption("Таблица с номера на виртуални страници, принадлежащи на даден процес", -1);
    q4.AddOption("Таблица на страниците на диска", -1);
    exam.push_back(q4);

    Question q5("Коя от изброените характеристики не описва таблицата на страниците?");
    q5.AddOption(
            "Таблицата на страниците се състои от редове, всеки ред от таблицата съответства на номер на виртуална страница",
            -1);
    q5.AddOption("Таблицата на страниците съдържа информация за активните процеси", 1);
    q5.AddOption(
            "Таблицата на страниците е допълнена с бит за присъствие, показващ дали съответната страница се намира в свободната памет",
            -1);
    q5.AddOption("Таблицата на страниците се пази някъде в оперативната памет", -1);
    exam.push_back(q5);

    Question q6("Какво е предназначението на TLB?");
    q6.AddOption("Да минимизира загубата на бързодействие при търсене на физическото разположение на данните", 1);
    q6.AddOption("Да преобразува виртуалните странични адреси във физически", -1);
    q6.AddOption("Да намали производителността на хардуерна имплементация", -1);
    exam.push_back(q6);

    Question q7(
            "Какви типове памет се използват за съхранение и поддържане на таблиците на страниците при статична организация на паметта?");
    q7.AddOption("Кешова с директна организация", -1);
    q7.AddOption("Асоциативни кешове", 0.5);
    q7.AddOption("Множество асоциативно кешове", 0.5);
    q7.AddOption("Външна дискова памет", -1);
    q7.AddOption("Главна памет", -1);
    exam.push_back(q7);

    //addressing modes
    Question q8("Посочете за кой от изброените режими на адресация се отнася показаната фигура\n| код | операнд |");
    q8.AddOption("Индексна", -1);
    q8.AddOption("Косвена", -1);
    q8.AddOption("Вложена", -1);
    q8.AddOption("Непосредствена", 1);
    exam.push_back(q8);

    Question q9("Как се оказва стойността на операнда при регистров режим на адресация?");
    q9.AddOption("Задава се в кода на инструкцията", -1);
    q9.AddOption("Задава се чрез константно отместване спрямо началото на програмния сегмент", -1);
    q9.AddOption("Задава се с номера на регистъра", 1);
    exam.push_back(q9);

    Question q10(
            "При кой от изброените методи на адресация в адресната част на инструкцията е записан адресен указател?");
    q10.AddOption("Индексна адресация", -1);
    q10.AddOption("Директна адресация", -1);
    q10.AddOption("Индексна адресация с регистри", -1);
    q10.AddOption("Непосредствена адресация", -1);
    q10.AddOption("Индиректна адресация", 1);
    exam.push_back(q10);

    Question q12("Къде е местоположението на операнда при регистрово косвена адресация?");
    q12.AddOption("В регистър", -1);
    q12.AddOption("В основната памет", 1);
    q12.AddOption("Във вторичната памет", -1);
    q12.AddOption("В кода на инструкцията", -1);
    exam.push_back(q12);

    Question q13("Как се указва ефективния адрес на операнда в паметта при непосредствен режим на адресация?");
    q13.AddOption("Чрез адрес на регистър на микропроцесора", -1);
    q13.AddOption("Чрез стековия указател", -1);
    q13.AddOption("Чрез адресното поле на операнда в кода на инструкцията", 1);
    exam.push_back(q13);

    Question q28("Колко е максималният брой страници с размер 8 при 8-битов адрес?");
    q28.AddOption("16", -1);
    q28.AddOption("32", 1);
    q28.AddOption("64", -1);
    q28.AddOption("512", -1);
    q28.AddOption("4k", -1);
    exam.push_back(q28);

    Question q29("При размер на страниците 8 и 8-битов адрес, кой ред на таблицата съдържа адреса на страницата?");
    q29.AddOption("3", 1);
    q29.AddOption("5", -1);
    q29.AddOption("7", -1);
    q29.AddOption("10", -1);
    q29.AddOption("12", -1);
    exam.push_back(q29);

    //pipelining
    Question u7(
            "Посочете при конвейерната обработка на коя от дадените последователности от инструкции възниква хазарт от типа write-after-read:");
    u7.AddOption("ADD R3, R2, R1; R3 = R2 + R1", -1);
    u7.AddOption("ADD R3, R2, R1; R3=R2+R1  SUB R2, R3, 1; R2=R3-1  ADD R3, R2, R5; R3 = R2+R5", 1);
    u7.AddOption("ADD R3, R4, R5 SUB R2, R2, 1 BEQ R2, R0, L1", -1);
    exam.push_back(u7);

    Question u8(
            "Знаейки, че ускорението е правопропорционално на броя фази на конвейера, защо реално полученото ускорение е по-малко в сравнение с теоретично достижимото?");
    u8.AddOption("Заради хазартите", 0.5);
    u8.AddOption("Заради по-високата патентност за индивидуалните инструкции", -1);
    u8.AddOption("Заради времето необходимо за запълване на конвейера", 0.5);
    exam.push_back(u8);

    Question u9("Разделянето на инструкциите на отделни фази на обработка е характерно за (изберете едно или повече):");
    u9.AddOption("разпределената обработка", -1);
    u9.AddOption("паралелната обработка", -1);
    u9.AddOption("системната обработка", -1);
    u9.AddOption("конвейерната обработка", 0.5);
    u9.AddOption("поддържането на паралелизъм на ниво инструкции", 0.5);
    exam.push_back(u9);

    Question u10(
            "Колко машинни цикъла ще са необходими за конвейерна обработка на 1500 инструкции в 5-фазен линеен инструкционен конвейер?");
    u10.AddOption("1505", -1);
    u10.AddOption("7500", -1);
    u10.AddOption("18", -1);
    u10.AddOption("1504", 1);
    exam.push_back(u10);

    Question u11(
            "Как се преодоляват хазартите в конвейера при достъп до общи ресурси в инструкционния поток (изберете едно или повече)?");
    u11.AddOption("чрез пренареждане на инструкционния поток от компилатора", -1);
    u11.AddOption("чрез предсказване на преходите в инструкционния поток", -1);
    u11.AddOption("чрез дублиране на критичните фази", -1);
    u11.AddOption("чрез блокиращи техники на конвейера за определено време и последователна обработка", 0.5);
    u11.AddOption("чрез прескачане на критичните фази", -1);
    u11.AddOption("чрез въвеждане на закъснения и модифициране главната таблица на заетост на конвейера", 0.5);
    exam.push_back(u11);

    Question u12("В инструкционния конвейер се изпълняват едновременно (изберете едно):");
    u12.AddOption("Празни инструкции", -1);
    u12.AddOption("Инструкции за условен и безусловен преход", -1);
    u12.AddOption("Инструкции в реални фази", 1);
    u12.AddOption("Записи на данни от регистрите към процесора", -1);
    exam.push_back(u12);

    Question u13(
            "Кои от изброените техники се използват при разрешаването на проблеми при конвейерното изпълнение на инструкции с преход (изберете едно или повече)?");
    u13.AddOption("Дублиране на конвейерните ресурси", -1);
    u13.AddOption("Множествено предварително изпълване на инструкции", 1);
    u13.AddOption("Prediction Look-up Table", -1);
    u13.AddOption(
            "Използване на специализирани функционални устройства за четене на операциите или запис на резултатите в паметта",
            -1);
    u13.AddOption("BTB buffer", -1);
    exam.push_back(u13);

    Question u14("Как се преодоляват конфликтите за памет при конвейеризираното изпълнение на инструкционния поток?");
    u14.AddOption("чрез въвеждане на закъснения и модифициране изходната таблица на заетост на конвейера", -1);
    u14.AddOption("чрез предсказване на преходите в инструкционния поток", 1);
    u14.AddOption("чрез пренареждане на инструкционния поток от компилатора", -1);
    u14.AddOption(
            "чрез използване на специализирано функционално устройство за четене на операциите или запис на резултати в паметта",
            -1);
    exam.push_back(u14);

    Question u15(
            "Посочете кои от изброените фактори са причина за понижаване на потоковата скорост при конвейерната обработка (изберете едно или повече):");
    u15.AddOption("Зависимости по данни", 0.25);
    u15.AddOption("Предсказване на прехода в информационния поток", -1);
    u15.AddOption("Темп на инициализация на конвейера", -1);
    u15.AddOption("Конфликти при достъп на общи ресурси", 0.25);
    u15.AddOption("Патентност на конвейерната обработка", -1);
    u15.AddOption("Използваемост на функционалните устройства по конвейера", -1);
    u15.AddOption("Анти-зависимости по данни", 0.25);
    u15.AddOption("Преходи в информационния поток, засягащи модифицирането на програмния брояч", 0.25);
    exam.push_back(u15);

    Question u16("На какво се дължат процедурните зависимости?");
    u16.AddOption("Единствено на инструкции за безусловен преход", -1);
    u16.AddOption("Единствено на инструкции за условен преход", -1);
    u16.AddOption(
            "Инструкции за безусловен преход и инструкции с осъществен условен преход в инструкционния поток на програмата",
            1);
    u16.AddOption("Едновременни заявки за един и същ ресурс", -1);
    exam.push_back(u16);

    Question u17("От какво се предизвикват ресурсните конфликти?");
    u17.AddOption("Недобро планиране на ресурсите на инструкционния конвейер", -1);
    u17.AddOption("Едновременни заявки за едни и същи ресурси", 1);
    u17.AddOption("От възникнали мехури в конвейера", -1);
    exam.push_back(u17);

    Question u18(
            "Кои от изброените методи се използва за решаване на проблема с инструкционните хазарти (изберете едно или повече)?");
    u18.AddOption("Презареждане на конвейера", -1);
    u18.AddOption("Увеличаване размера на буферната памет в отделните функционални устройства", -1);
    u18.AddOption("Опростяване формата на инструкциите използвани от програмата", -1);
    u18.AddOption("Разделяне на инструкционния цикъл на допълнителни фази на обработка", -1);
    u18.AddOption("Пренареждане на инструкции от компилатора", 1);
    exam.push_back(u18);

    //random
    Question q14(
            "Суперскаларен процесор обработва два инструкционни потока (от прости и сложни инструкции). Коя от изброените фази на разработка е обща и за двата потока?");
    q14.AddOption("Извличане", 1);
    q14.AddOption("Изпълнение", -1);
    q14.AddOption("Запис на резултата", -1);
    q14.AddOption("Декодиране", -1);
    exam.push_back(q14);

    Question q15("Какво е предназначението на механизмите за защита на паметта?");
    q15.AddOption("Да не допускат модифициране на системния софтуер от приложения", -1);
    q15.AddOption("Да ограничават достъпа до съхраняванията в системата информация", -1);
    q15.AddOption("Да откриват грешки при адресирането преди извършването на неразрешен достъп", -1);
    q15.AddOption("Да ограничават достъпа до определени сегменти или страници", 1);
    exam.push_back(q15);

    Question q16("Шината PCI в процесорната архитектура се явява мост между:");
    q16.AddOption("шина EISA и периферията", 1);
    q16.AddOption("системната шина на микропроцесора и шината EISA", -1);
    q16.AddOption("системната шина на микропроцесора и основната памет", -1);
    q16.AddOption("микропроцесора и кеш-паметта L2", -1);
    exam.push_back(q16);

    Question q17("Коя/кои от изброените шини не са част от системната шина?");
    q17.AddOption("Шина за данни", -1);
    q17.AddOption("Шина за логически сигнали", 1);
    q17.AddOption("Контролна шина", -1);
    q17.AddOption("Адресна шина", -1);
    exam.push_back(q17);

    Question q18("В режим на директен достъп до паметта, управлението на обмена се поема от:");
    q18.AddOption("Устройството за вход/изход", 1);
    q18.AddOption("Процесора", -1);
    q18.AddOption("Главната памет", -1);
    exam.push_back(q18);

    Question q26("Колко проводна може да бъде USB платината?");
    q26.AddOption("4", 0.5);
    q26.AddOption("9", 0.5);
    q26.AddOption("6", -1);
    exam.push_back(q26);

    Question q27("Коя е правилната дефиниция за термина CISC");
    q27.AddOption("Complex Instruction Set Computing", 1);
    q27.AddOption("Corect Index System Call", -1);
    q27.AddOption("Chip Ignore Call", -1);
    q27.AddOption("Central Integer Stack Index", -1);
    exam.push_back(q27);

    Question q39("Коя е правилната дефиниция за термина RISC");
    q39.AddOption("Reduced Instruction Set Computing", 1);
    q39.AddOption("Random Index System Call", -1);
    q39.AddOption("Risk Instruction Stack Call", -1);
    q39.AddOption("Real Invested Space Capacity ", -1);
    exam.push_back(q39);

    //ISA
    Question q19(
            "В зависимост от режима на адресация времето на изпълнение на една процесорна инструкция може да варира в значителна степен. При коя от изброените подредби на адресни режими времето ще се изменя от много кратко до много дълго?");
    q19.AddOption("директна, косвена, непосредствена", -1);
    q19.AddOption("непосредствена, косвена, директна", -1);
    q19.AddOption("непосредствена, директна, косвена", 1);
    q19.AddOption("косвена, непосредствена, директна", -1);
    exam.push_back(q19);

    Question q20("Кой от изброените етапи не е част от инструкционния цикъл?");
    q20.AddOption("Пренареждане", 1);
    q20.AddOption("Извличане", -1);
    q20.AddOption("Изпълнение", -1);
    q20.AddOption("Декодиране", -1);
    exam.push_back(q20);

    Question q21("Кои процесори от изброените процесорни фамилии се характеризират с RISC-архитектура?");
    q21.AddOption("SPARC", 0.33);
    q21.AddOption("CYRIX", -1);
    q21.AddOption("ALPHA", -1);
    q21.AddOption("INTEL", -1);
    q21.AddOption("AMD", -1);
    q21.AddOption("MIPS-R4000", 0.34);
    q21.AddOption("ARM", 0.33);
    exam.push_back(q21);

    Question q22("Каква система инструкции имат различните фамилии мултипроцесорни архитектури?");
    q22.AddOption("Еднаква", -1);
    q22.AddOption("Съвпадаща отчасти", 0.5);
    q22.AddOption("Изцяло различна", 0.5);
    exam.push_back(q22);

    Question q23("Кой/кои от изброените етапи е част от инструкционния цикъл?");
    q23.AddOption("Пренареждане", -1);
    q23.AddOption("Извличане", 0.34);
    q23.AddOption("Изпълнение", 0.33);
    q23.AddOption("Декодиране", 0.33);
    exam.push_back(q23);

    Question q24("Кое от твърденията относно размера на страниците е невярно?");
    q24.AddOption(
            "По-големият размер на страниците увеличава времето за входно-изходни операции (четене, запис на страници) по време на изпълнение на програмите",
            1);
    q24.AddOption("По-големият размер води до въвеждане на излишна информация, която може да е излишна", -1);
    q24.AddOption(
            "По-малкият размер на страницата води до намаляване на вътрешната фрагментация, която е 1/2 от последната страница",
            -1);
    exam.push_back(q24);

    //komp arch
    Question u1("От кои фактори зависи производителността на компютърните системи?");
    u1.AddOption("От времето за достъп до регистриране", -1);
    u1.AddOption("Архитектурата и технологията", 1);
    u1.AddOption("От тактовата честота", -1);
    exam.push_back(u1);

    Question u2(
            "Единицата за измерване на производителността MIPS за съпоставяне на еднотипни процесорни архитектури се основава на:");
    u2.AddOption("Брой операции с операнди от виртуалната памет", -1);
    u2.AddOption("Брой операции с операнди от кеш-паметта", -1);
    u2.AddOption("Брой операции с операнди от главната памет", 1);
    u2.AddOption("Брой операции с операнди от флаш-паметта", -1);
    exam.push_back(u2);

    Question u3("Основни производители на x86 архитектурата са (изберете едно или повече):");
    u3.AddOption("IBM", 0.34);
    u3.AddOption("Hewlett-Packard", 0.33);
    u3.AddOption("Intel", 0.33);
    u3.AddOption("Sun Microsystems", -1);
    u3.AddOption("Advanced Micro Device", -1);
    exam.push_back(u3);

    Question u4("За какво служи програмният брояч (изберете едно)?");
    u4.AddOption("За указване на адреса на следващата инструкция за изпълнение", 1);
    u4.AddOption("За съхраняване на резултата от аритметичните операции изпълнявани в ALU-то", -1);
    u4.AddOption("За отчитане броя на изпълненията на дадена инструкция", -1);
    u4.AddOption("За отчитане на процента памет заеман от изпълняващата се програма", -1);
    exam.push_back(u4);

    Question u5("Коя е правилната дефиниция за термина SIMD (изберете едно)?");
    u5.AddOption("Single Instruction, Multiple Data", 1);
    u5.AddOption("Single Interrupt, Multiple Distribution", -1);
    u5.AddOption("Single Input, Multiple Distributions", -1);
    u5.AddOption("Single Integration, Multiple Dynamics", -1);
    exam.push_back(u5);

    Question u6(
            "Кои от изброените техники служат за увеличаване степента на паралелизъм по време на изпълнение на програмата (изберете едно или повече)?");
    u6.AddOption("Нито едно от посочените", -1);
    u6.AddOption("Прогнозиране посоката на преходите", 0.25);
    u6.AddOption("Едновременно зареждане за изпълнение на няколко инструкции и динамично планиране", 0.25);
    u6.AddOption("Откриване и премахване на зависимости по данни при компилиране", 0.25);
    u6.AddOption(
            "Реорганизация на циклите по такъв начин, че всяка итерация в получения код да се състои от инструкции, които са избрани от различни итерации на първоначалния цикъл (loop unrolling)",
            0.25);
    exam.push_back(u6);

    Question q30("Кои от изброените характеризира архитектурната концепция EPIC?");
    q30.AddOption(
            "Оползотворяване паралелизъм на ниво инструкция чрез изпращане на няколко инструкции на обикновения инструкционен поток в различни функционални устройства на конвейера",
            -1);
    q30.AddOption("Оползотворяване на явен паралелизъм на ниво инструкция", 0.34);
    q30.AddOption("Оползотворяване на скрития в програмния код на ниво компилатор и апаратна поддръжка", 0.33);
    q30.AddOption("Едновременно зареждане за изпълнение на няколко инструкции и динамично планиране", -1);
    q30.AddOption("Използване на широка шина за зареждане на инструкция и дълги конвейери с голяма задръжка", 0.33);
    exam.push_back(q30);

    Question q32(
            "За коя от изброените компютърни архитектури се отнасят следните особености:\n-Дължината на инструкциите е стотици битове\n-В рамките на процесора функционират паралелно множество функционални устройства\n-Всички функционални устройства споделят огромен общ регистров файл");
    q32.AddOption("Потокова", -1);
    q32.AddOption("Суперскаларна", -1);
    q32.AddOption("VLIW", 1);
    q32.AddOption("EPIC", -1);
    exam.push_back(q32);

    Question q34("По какво се различават CISC от RISC?");
    q34.AddOption("Всички инструкции се характеризират с опростен формат", 1);
    q34.AddOption("Инструкциите преобладаващо са от тип памет-памет", -1);
    q34.AddOption("Всички инструкции се характеризират с една и съща дължина", -1);
    q34.AddOption("Сложните инструкции се синтезират от по-простите", -1);
    q34.AddOption("Операциите с паметта са само от типа \"Load\" и \"store\"", -1);
    exam.push_back(q34);

    Question q35(
            "От какво се определя времето за изпълнение на програмата в процесора:\n1)алгоритъма 2)програмния език 3)компилатора 4)системата процесорни инструкции");
    q35.AddOption("1) и 3)", 1);//in Kosyo we trust
    q35.AddOption("3) и 4)", -1);
    q35.AddOption("1), 2), 3 и 4))", -1);
    q35.AddOption("1) и 2)", -1);
    q35.AddOption("2) и 3)", -1);
    q35.AddOption("2), 3) и 4)", -1);
    exam.push_back(q35);

    Question q38("От какъв тип е следната инструкция?\nADD 5,15,20");
    q38.AddOption("RISC", -1);
    q38.AddOption("CISC", 1);
    q38.AddOption("VLIW", -1);
    exam.push_back(q38);

    unsigned questionsCount = exam.size();
    for (unsigned i = 0; i < questionsCount; ++i)
        std::swap(exam[Randomize(exam.size())], exam[Randomize(exam.size())]);
    for (unsigned i = 0; i < exam.size(); ++i) {
        if (i == questionsCount) {
            std::cout << "Секция със сгрешени въпроси\nнатиснете някой бутон\n";
            std::cin >> useless;
            system("CLS");
        }
        std::cout << 1 + i << '/' << exam.size() << '\n';
        exam[i].AskQuestion();
        if (exam[i].AnswerQuestion() != 1 && !flag)
            exam.push_back(exam[i]);
        std::cin >> useless;
        system("CLS");
    }
    std::cout << "Congratulations for reaching the end!\nYour score is: " << counter << '/' << exam.size();
    std::cin >> useless;
    return 0;
}